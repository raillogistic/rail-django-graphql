name: Deploy to Environments

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types: [completed]
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (tag or commit SHA)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Determine deployment environment and version
  prepare:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      version: ${{ steps.env.outputs.version }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}

    steps:
      - name: Determine environment and version
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "version=${{ github.event.inputs.version || github.sha }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            if [[ "${{ github.event.workflow_run.head_branch }}" == "develop" ]]; then
              echo "environment=staging" >> $GITHUB_OUTPUT
              echo "version=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
              echo "should_deploy=true" >> $GITHUB_OUTPUT
            elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
              echo "environment=production" >> $GITHUB_OUTPUT
              echo "version=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
              echo "should_deploy=true" >> $GITHUB_OUTPUT
            else
              echo "should_deploy=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # Deploy to staging environment
  deploy-staging:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true' && needs.prepare.outputs.environment == 'staging'
    environment: 
      name: staging
      url: https://staging.example.com

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy to staging
        env:
          DEPLOY_HOST: ${{ secrets.STAGING_HOST }}
          DEPLOY_USER: ${{ secrets.STAGING_USER }}
          DEPLOY_KEY: ${{ secrets.STAGING_SSH_KEY }}
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          SECRET_KEY: ${{ secrets.STAGING_SECRET_KEY }}
          REDIS_URL: ${{ secrets.STAGING_REDIS_URL }}
        run: |
          # Create deployment directory
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Copy docker-compose files to staging server
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            deploy/docker-compose.production.yml \
            $DEPLOY_USER@$DEPLOY_HOST:/opt/django-graphql/
          
          # Deploy using docker-compose
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
            cd /opt/django-graphql
            
            # Set environment variables
            export IMAGE_TAG=${{ needs.prepare.outputs.version }}
            export DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}
            export SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}
            export REDIS_URL=${{ secrets.STAGING_REDIS_URL }}
            export DEBUG=False
            export ENVIRONMENT=staging
            
            # Pull latest images
            docker-compose -f docker-compose.production.yml pull
            
            # Run database migrations
            docker-compose -f docker-compose.production.yml run --rm web python manage.py migrate
            
            # Collect static files
            docker-compose -f docker-compose.production.yml run --rm web python manage.py collectstatic --noinput
            
            # Deploy with zero-downtime
            docker-compose -f docker-compose.production.yml up -d
            
            # Health check
            sleep 30
            curl -f http://localhost/health/ || exit 1
          EOF

      - name: Run post-deployment tests
        run: |
          # Run smoke tests against staging environment
          curl -f https://staging.example.com/health/
          curl -f https://staging.example.com/graphql/ -X POST \
            -H "Content-Type: application/json" \
            -d '{"query": "{ __schema { types { name } } }"}'

      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: "✅ Staging deployment successful for version ${{ needs.prepare.outputs.version }}"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify deployment failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: "❌ Staging deployment failed for version ${{ needs.prepare.outputs.version }}"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Deploy to production environment
  deploy-production:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true' && needs.prepare.outputs.environment == 'production'
    environment: 
      name: production
      url: https://api.example.com

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Blue-Green deployment to production
        env:
          DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
          DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
          DEPLOY_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          SECRET_KEY: ${{ secrets.PRODUCTION_SECRET_KEY }}
          REDIS_URL: ${{ secrets.PRODUCTION_REDIS_URL }}
        run: |
          # Create deployment directory
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Copy deployment scripts to production server
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            deploy/docker-compose.production.yml \
            deploy/scripts/blue-green-deploy.sh \
            $DEPLOY_USER@$DEPLOY_HOST:/opt/django-graphql/
          
          # Execute blue-green deployment
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
            cd /opt/django-graphql
            
            # Set environment variables
            export IMAGE_TAG=${{ needs.prepare.outputs.version }}
            export DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}
            export SECRET_KEY=${{ secrets.PRODUCTION_SECRET_KEY }}
            export REDIS_URL=${{ secrets.PRODUCTION_REDIS_URL }}
            export DEBUG=False
            export ENVIRONMENT=production
            
            # Execute blue-green deployment script
            chmod +x blue-green-deploy.sh
            ./blue-green-deploy.sh
          EOF

      - name: Run production health checks
        run: |
          # Comprehensive health checks
          curl -f https://api.example.com/health/
          curl -f https://api.example.com/health/db/
          curl -f https://api.example.com/health/cache/
          
          # GraphQL endpoint check
          curl -f https://api.example.com/graphql/ -X POST \
            -H "Content-Type: application/json" \
            -d '{"query": "{ __schema { types { name } } }"}'

      - name: Run performance tests
        run: |
          # Basic performance test
          curl -w "@curl-format.txt" -o /dev/null -s https://api.example.com/graphql/ \
            -X POST -H "Content-Type: application/json" \
            -d '{"query": "{ __schema { types { name } } }"}'

      - name: Update monitoring dashboards
        run: |
          # Update Grafana dashboards with new deployment info
          curl -X POST "${{ secrets.GRAFANA_API_URL }}/api/annotations" \
            -H "Authorization: Bearer ${{ secrets.GRAFANA_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "Production deployment: ${{ needs.prepare.outputs.version }}",
              "tags": ["deployment", "production"],
              "time": '$(date +%s000)'
            }'

      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: "🚀 Production deployment successful for version ${{ needs.prepare.outputs.version }}"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify deployment failure and rollback
        if: failure()
        run: |
          # Trigger rollback
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
            cd /opt/django-graphql
            ./rollback.sh
          EOF
          
          # Notify failure
          curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d '{
              "text": "❌ Production deployment failed for version ${{ needs.prepare.outputs.version }}. Rollback initiated."
            }'

  # Database migrations (separate job for safety)
  migrate-database:
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging]
    if: needs.prepare.outputs.environment == 'production' && needs.deploy-staging.result == 'success'
    environment: production-db

    steps:
      - name: Run database migrations
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
          DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
          DEPLOY_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            $DEPLOY_USER@$DEPLOY_HOST << 'EOF'
            cd /opt/django-graphql
            
            # Backup database before migration
            docker-compose -f docker-compose.production.yml exec -T db \
              pg_dump -U postgres django_graphql > backup_$(date +%Y%m%d_%H%M%S).sql
            
            # Run migrations
            docker-compose -f docker-compose.production.yml run --rm web \
              python manage.py migrate --noinput
          EOF