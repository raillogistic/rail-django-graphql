#!/usr/bin/env python3
"""
Test complet pour v√©rifier l'invalidation du cache via les signaux Django
Ce test v√©rifie que tous les changements CRUD d√©clenchent l'invalidation du cache
"""

import os
import sys
import django
import json
import requests
import time
from datetime import datetime

# Configuration Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django_graphql_auto.settings')
django.setup()

from django.core.cache import cache
from django.db import transaction
from test_app.models import Category, Tag

# Configuration du serveur GraphQL
GRAPHQL_URL = "http://127.0.0.1:8000/graphql/"
HEADERS = {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
}

def log_test_step(step_name, details=""):
    """Log une √©tape de test avec timestamp"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"\n[{timestamp}] üß™ {step_name}")
    if details:
        print(f"   üìù {details}")

def execute_graphql_query(query, variables=None):
    """Ex√©cute une requ√™te GraphQL"""
    payload = {
        'query': query,
        'variables': variables or {}
    }
    
    try:
        response = requests.post(GRAPHQL_URL, json=payload, headers=HEADERS, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Erreur de requ√™te: {e}")
        return None

def test_server_connection():
    """Test la connexion au serveur GraphQL"""
    log_test_step("Test de connexion au serveur GraphQL")
    
    query = """
    query TestConnection {
        __schema {
            queryType {
                name
            }
        }
    }
    """
    
    result = execute_graphql_query(query)
    if result and 'data' in result:
        print("‚úÖ Serveur GraphQL accessible")
        return True
    else:
        print("‚ùå Serveur GraphQL inaccessible")
        return False

def get_categories_count():
    """R√©cup√®re le nombre de cat√©gories via GraphQL"""
    query = """
    query GetCategories {
        categories {
            edges {
                node {
                    id
                    name
                }
            }
        }
    }
    """
    
    result = execute_graphql_query(query)
    if result and 'data' in result and result['data']['categories']:
        return len(result['data']['categories']['edges'])
    return 0

def test_direct_model_operations():
    """Test les op√©rations directes sur les mod√®les (sans GraphQL)"""
    log_test_step("Test des op√©rations directes sur les mod√®les")
    
    # 1. V√©rifier l'√©tat initial du cache
    initial_count = get_categories_count()
    print(f"   üìä Nombre initial de cat√©gories (via GraphQL): {initial_count}")
    
    # 2. Cr√©er une cat√©gorie directement via le mod√®le Django
    log_test_step("Cr√©ation directe d'une cat√©gorie via le mod√®le Django")
    with transaction.atomic():
        new_category = Category.objects.create(
            name=f"Test Direct Category {datetime.now().strftime('%H%M%S')}",
            description="Cr√©√©e directement via le mod√®le Django"
        )
        print(f"   ‚úÖ Cat√©gorie cr√©√©e: {new_category.name} (ID: {new_category.id})")
    
    # 3. Attendre un peu pour que les signaux se d√©clenchent
    time.sleep(0.5)
    
    # 4. V√©rifier que le cache a √©t√© invalid√©
    log_test_step("V√©rification de l'invalidation du cache apr√®s cr√©ation directe")
    new_count = get_categories_count()
    print(f"   üìä Nouveau nombre de cat√©gories (via GraphQL): {new_count}")
    
    if new_count > initial_count:
        print("   ‚úÖ Cache invalid√© correctement - nouvelle cat√©gorie visible")
        cache_invalidated = True
    else:
        print("   ‚ùå Cache non invalid√© - nouvelle cat√©gorie non visible")
        cache_invalidated = False
    
    # 5. Modifier la cat√©gorie
    log_test_step("Modification directe de la cat√©gorie")
    new_category.description = f"Modifi√©e √† {datetime.now().strftime('%H:%M:%S')}"
    new_category.save()
    print(f"   ‚úÖ Cat√©gorie modifi√©e: {new_category.name}")
    
    # 6. Supprimer la cat√©gorie
    log_test_step("Suppression directe de la cat√©gorie")
    category_id = new_category.id
    new_category.delete()
    print(f"   ‚úÖ Cat√©gorie supprim√©e (ID: {category_id})")
    
    # 7. V√©rifier que le cache a √©t√© invalid√© apr√®s suppression
    time.sleep(0.5)
    final_count = get_categories_count()
    print(f"   üìä Nombre final de cat√©gories (via GraphQL): {final_count}")
    
    if final_count == initial_count:
        print("   ‚úÖ Cache invalid√© correctement apr√®s suppression")
        return cache_invalidated and True
    else:
        print("   ‚ùå Cache non invalid√© apr√®s suppression")
        return False

def test_bulk_operations():
    """Test les op√©rations en lot"""
    log_test_step("Test des op√©rations en lot")
    
    initial_count = get_categories_count()
    
    # Cr√©er plusieurs cat√©gories en lot
    categories_to_create = [
        Category(name=f"Bulk Category {i}", description=f"Cat√©gorie en lot {i}")
        for i in range(3)
    ]
    
    with transaction.atomic():
        Category.objects.bulk_create(categories_to_create)
        print(f"   ‚úÖ {len(categories_to_create)} cat√©gories cr√©√©es en lot")
    
    time.sleep(0.5)
    
    # V√©rifier l'invalidation
    new_count = get_categories_count()
    print(f"   üìä Nombre de cat√©gories apr√®s cr√©ation en lot: {new_count}")
    
    # Nettoyer
    Category.objects.filter(name__startswith="Bulk Category").delete()
    
    if new_count > initial_count:
        print("   ‚úÖ Cache invalid√© correctement pour les op√©rations en lot")
        return True
    else:
        print("   ‚ùå Cache non invalid√© pour les op√©rations en lot")
        return False

def test_many_to_many_operations():
    """Test les op√©rations many-to-many"""
    log_test_step("Test des op√©rations many-to-many")
    
    # Cr√©er une cat√©gorie et des tags
    category = Category.objects.create(
        name=f"M2M Test Category {datetime.now().strftime('%H%M%S')}",
        description="Pour tester les relations M2M"
    )
    
    tag1 = Tag.objects.create(name=f"M2M Tag 1 {datetime.now().strftime('%H%M%S')}")
    tag2 = Tag.objects.create(name=f"M2M Tag 2 {datetime.now().strftime('%H%M%S')}")
    
    print(f"   ‚úÖ Cat√©gorie et tags cr√©√©s")
    
    # Ajouter des tags √† la cat√©gorie (si la relation existe)
    try:
        if hasattr(category, 'tags'):
            category.tags.add(tag1, tag2)
            print(f"   ‚úÖ Tags ajout√©s √† la cat√©gorie")
            
            time.sleep(0.5)
            
            # Supprimer un tag
            category.tags.remove(tag1)
            print(f"   ‚úÖ Tag supprim√© de la cat√©gorie")
            
            # Nettoyer
            category.tags.clear()
            
        else:
            print(f"   ‚ÑπÔ∏è Pas de relation M2M tags sur Category")
            
    except Exception as e:
        print(f"   ‚ö†Ô∏è Erreur lors du test M2M: {e}")
    
    # Nettoyer
    category.delete()
    tag1.delete()
    tag2.delete()
    
    return True

def test_graphql_mutations_with_signals():
    """Test les mutations GraphQL avec les signaux"""
    log_test_step("Test des mutations GraphQL avec signaux")
    
    initial_count = get_categories_count()
    
    # Mutation GraphQL
    mutation = """
    mutation CreateCategory($input: CreateCategoryInput!) {
        createCategory(input: $input) {
            category {
                id
                name
                description
            }
            success
            errors
        }
    }
    """
    
    variables = {
        "input": {
            "name": f"GraphQL Signal Test {datetime.now().strftime('%H%M%S')}",
            "description": "Cr√©√©e via mutation GraphQL avec signaux"
        }
    }
    
    result = execute_graphql_query(mutation, variables)
    
    if result and 'data' in result and result['data']['createCategory']['success']:
        category_id = result['data']['createCategory']['category']['id']
        print(f"   ‚úÖ Cat√©gorie cr√©√©e via GraphQL (ID: {category_id})")
        
        time.sleep(0.5)
        
        # V√©rifier l'invalidation
        new_count = get_categories_count()
        
        if new_count > initial_count:
            print("   ‚úÖ Cache invalid√© correctement pour mutation GraphQL")
            return True
        else:
            print("   ‚ùå Cache non invalid√© pour mutation GraphQL")
            return False
    else:
        print(f"   ‚ùå √âchec de la mutation GraphQL: {result}")
        return False

def run_comprehensive_test():
    """Lance tous les tests de mani√®re s√©quentielle"""
    print("üöÄ D√âBUT DES TESTS COMPLETS D'INVALIDATION DU CACHE VIA SIGNAUX")
    print("=" * 80)
    
    # V√©rifier la connexion
    if not test_server_connection():
        print("‚ùå Impossible de continuer sans connexion au serveur")
        return False
    
    # Effacer le cache au d√©but
    log_test_step("Nettoyage initial du cache")
    cache.clear()
    print("   ‚úÖ Cache effac√©")
    
    # Tests
    results = []
    
    try:
        # Test 1: Op√©rations directes sur les mod√®les
        results.append(("Op√©rations directes", test_direct_model_operations()))
        
        # Test 2: Op√©rations en lot
        results.append(("Op√©rations en lot", test_bulk_operations()))
        
        # Test 3: Op√©rations many-to-many
        results.append(("Op√©rations M2M", test_many_to_many_operations()))
        
        # Test 4: Mutations GraphQL avec signaux
        results.append(("Mutations GraphQL", test_graphql_mutations_with_signals()))
        
    except Exception as e:
        print(f"‚ùå Erreur lors des tests: {e}")
        return False
    
    # R√©sum√© des r√©sultats
    print("\n" + "=" * 80)
    print("üìä R√âSUM√â DES TESTS")
    print("=" * 80)
    
    all_passed = True
    for test_name, result in results:
        status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHOU√â"
        print(f"   {test_name}: {status}")
        if not result:
            all_passed = False
    
    print("\n" + "=" * 80)
    if all_passed:
        print("üéâ TOUS LES TESTS SONT R√âUSSIS!")
        print("‚úÖ Le middleware avec signaux Django fonctionne correctement")
        print("‚úÖ Toutes les op√©rations CRUD d√©clenchent l'invalidation du cache")
    else:
        print("‚ö†Ô∏è CERTAINS TESTS ONT √âCHOU√â")
        print("‚ùå V√©rifiez la configuration du middleware et des signaux")
    
    print("=" * 80)
    return all_passed

if __name__ == "__main__":
    success = run_comprehensive_test()
    sys.exit(0 if success else 1)